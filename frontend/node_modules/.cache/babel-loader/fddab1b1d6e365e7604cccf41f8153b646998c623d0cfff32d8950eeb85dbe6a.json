{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = highlight;\nexports.shouldHighlight = shouldHighlight;\nvar _jsTokens = require(\"js-tokens\");\nvar _helperValidatorIdentifier = require(\"@babel/helper-validator-identifier\");\nvar _chalk = _interopRequireWildcard(require(\"chalk\"), true);\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nconst sometimesKeywords = new Set([\"as\", \"async\", \"from\", \"get\", \"of\", \"set\"]);\nfunction getDefs(chalk) {\n  return {\n    keyword: chalk.cyan,\n    capitalized: chalk.yellow,\n    jsxIdentifier: chalk.yellow,\n    punctuator: chalk.yellow,\n    number: chalk.magenta,\n    string: chalk.green,\n    regex: chalk.magenta,\n    comment: chalk.grey,\n    invalid: chalk.white.bgRed.bold\n  };\n}\nconst NEWLINE = /\\r\\n|[\\n\\r\\u2028\\u2029]/;\nconst BRACKET = /^[()[\\]{}]$/;\nlet tokenize;\n{\n  const JSX_TAG = /^[a-z][\\w-]*$/i;\n  const getTokenType = function (token, offset, text) {\n    if (token.type === \"name\") {\n      if ((0, _helperValidatorIdentifier.isKeyword)(token.value) || (0, _helperValidatorIdentifier.isStrictReservedWord)(token.value, true) || sometimesKeywords.has(token.value)) {\n        return \"keyword\";\n      }\n      if (JSX_TAG.test(token.value) && (text[offset - 1] === \"<\" || text.slice(offset - 2, offset) == \"</\")) {\n        return \"jsxIdentifier\";\n      }\n      if (token.value[0] !== token.value[0].toLowerCase()) {\n        return \"capitalized\";\n      }\n    }\n    if (token.type === \"punctuator\" && BRACKET.test(token.value)) {\n      return \"bracket\";\n    }\n    if (token.type === \"invalid\" && (token.value === \"@\" || token.value === \"#\")) {\n      return \"punctuator\";\n    }\n    return token.type;\n  };\n  tokenize = function* (text) {\n    let match;\n    while (match = _jsTokens.default.exec(text)) {\n      const token = _jsTokens.matchToToken(match);\n      yield {\n        type: getTokenType(token, match.index, text),\n        value: token.value\n      };\n    }\n  };\n}\nfunction highlightTokens(defs, text) {\n  let highlighted = \"\";\n  for (const {\n    type,\n    value\n  } of tokenize(text)) {\n    const colorize = defs[type];\n    if (colorize) {\n      highlighted += value.split(NEWLINE).map(str => colorize(str)).join(\"\\n\");\n    } else {\n      highlighted += value;\n    }\n  }\n  return highlighted;\n}\nfunction shouldHighlight(options) {\n  return _chalk.default.level > 0 || options.forceColor;\n}\nlet chalkWithForcedColor = undefined;\nfunction getChalk(forceColor) {\n  if (forceColor) {\n    var _chalkWithForcedColor;\n    (_chalkWithForcedColor = chalkWithForcedColor) != null ? _chalkWithForcedColor : chalkWithForcedColor = new _chalk.default.constructor({\n      enabled: true,\n      level: 1\n    });\n    return chalkWithForcedColor;\n  }\n  return _chalk.default;\n}\n{\n  exports.getChalk = options => getChalk(options.forceColor);\n}\nfunction highlight(code, options = {}) {\n  if (code !== \"\" && shouldHighlight(options)) {\n    const defs = getDefs(getChalk(options.forceColor));\n    return highlightTokens(defs, code);\n  } else {\n    return code;\n  }\n}","map":{"version":3,"names":["_jsTokens","require","_helperValidatorIdentifier","_chalk","_interopRequireWildcard","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","default","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","sometimesKeywords","Set","getDefs","chalk","keyword","cyan","capitalized","yellow","jsxIdentifier","punctuator","number","magenta","string","green","regex","comment","grey","invalid","white","bgRed","bold","NEWLINE","BRACKET","tokenize","JSX_TAG","getTokenType","token","offset","text","type","isKeyword","value","isStrictReservedWord","test","slice","toLowerCase","match","exec","matchToToken","index","highlightTokens","defs","highlighted","colorize","split","map","str","join","shouldHighlight","options","level","forceColor","chalkWithForcedColor","undefined","getChalk","_chalkWithForcedColor","constructor","enabled","exports","highlight","code"],"sources":["C:\\Users\\Windows10\\Documents\\GitHub\\RecipesProject\\frontend\\node_modules\\@babel\\highlight\\src\\index.ts"],"sourcesContent":["/// <reference path=\"../../../lib/third-party-libs.d.ts\" />\n\nimport type { Token as JSToken, JSXToken } from \"js-tokens\";\nimport jsTokens from \"js-tokens\";\n\nimport {\n  isStrictReservedWord,\n  isKeyword,\n} from \"@babel/helper-validator-identifier\";\n\nimport chalk, { Chalk as ChalkClass, type ChalkInstance as Chalk } from \"chalk\";\n\n/**\n * Names that are always allowed as identifiers, but also appear as keywords\n * within certain syntactic productions.\n *\n * https://tc39.es/ecma262/#sec-keywords-and-reserved-words\n *\n * `target` has been omitted since it is very likely going to be a false\n * positive.\n */\nconst sometimesKeywords = new Set([\"as\", \"async\", \"from\", \"get\", \"of\", \"set\"]);\n\ntype InternalTokenType =\n  | \"keyword\"\n  | \"capitalized\"\n  | \"jsxIdentifier\"\n  | \"punctuator\"\n  | \"number\"\n  | \"string\"\n  | \"regex\"\n  | \"comment\"\n  | \"invalid\";\n\ntype Token = {\n  type: InternalTokenType | \"uncolored\";\n  value: string;\n};\n/**\n * Chalk styles for token types.\n */\nfunction getDefs(chalk: Chalk): Record<InternalTokenType, Chalk> {\n  return {\n    keyword: chalk.cyan,\n    capitalized: chalk.yellow,\n    jsxIdentifier: chalk.yellow,\n    punctuator: chalk.yellow,\n    number: chalk.magenta,\n    string: chalk.green,\n    regex: chalk.magenta,\n    comment: chalk.grey,\n    invalid: chalk.white.bgRed.bold,\n  };\n}\n\n/**\n * RegExp to test for newlines in terminal.\n */\nconst NEWLINE = /\\r\\n|[\\n\\r\\u2028\\u2029]/;\n\n/**\n * RegExp to test for the three types of brackets.\n */\nconst BRACKET = /^[()[\\]{}]$/;\n\nlet tokenize: (\n  text: string,\n) => Generator<{ type: InternalTokenType | \"uncolored\"; value: string }>;\n\nif (process.env.BABEL_8_BREAKING) {\n  /**\n   * Get the type of token, specifying punctuator type.\n   */\n  const getTokenType = function (\n    token: JSToken | JSXToken,\n  ): InternalTokenType | \"uncolored\" {\n    if (token.type === \"IdentifierName\") {\n      if (\n        isKeyword(token.value) ||\n        isStrictReservedWord(token.value, true) ||\n        sometimesKeywords.has(token.value)\n      ) {\n        return \"keyword\";\n      }\n\n      if (token.value[0] !== token.value[0].toLowerCase()) {\n        return \"capitalized\";\n      }\n    }\n\n    if (token.type === \"Punctuator\" && BRACKET.test(token.value)) {\n      return \"uncolored\";\n    }\n\n    if (token.type === \"Invalid\" && token.value === \"@\") {\n      return \"punctuator\";\n    }\n\n    switch (token.type) {\n      case \"NumericLiteral\":\n        return \"number\";\n\n      case \"StringLiteral\":\n      case \"JSXString\":\n      case \"NoSubstitutionTemplate\":\n        return \"string\";\n\n      case \"RegularExpressionLiteral\":\n        return \"regex\";\n\n      case \"Punctuator\":\n      case \"JSXPunctuator\":\n        return \"punctuator\";\n\n      case \"MultiLineComment\":\n      case \"SingleLineComment\":\n        return \"comment\";\n\n      case \"Invalid\":\n      case \"JSXInvalid\":\n        return \"invalid\";\n\n      case \"JSXIdentifier\":\n        return \"jsxIdentifier\";\n\n      default:\n        return \"uncolored\";\n    }\n  };\n\n  /**\n   * Turn a string of JS into an array of objects.\n   */\n  tokenize = function* (text: string): Generator<Token> {\n    for (const token of jsTokens(text, { jsx: true })) {\n      switch (token.type) {\n        case \"TemplateHead\":\n          yield { type: \"string\", value: token.value.slice(0, -2) };\n          yield { type: \"punctuator\", value: \"${\" };\n          break;\n\n        case \"TemplateMiddle\":\n          yield { type: \"punctuator\", value: \"}\" };\n          yield { type: \"string\", value: token.value.slice(1, -2) };\n          yield { type: \"punctuator\", value: \"${\" };\n          break;\n\n        case \"TemplateTail\":\n          yield { type: \"punctuator\", value: \"}\" };\n          yield { type: \"string\", value: token.value.slice(1) };\n          break;\n\n        default:\n          yield {\n            type: getTokenType(token),\n            value: token.value,\n          };\n      }\n    }\n  };\n} else {\n  /**\n   * RegExp to test for what seems to be a JSX tag name.\n   */\n  const JSX_TAG = /^[a-z][\\w-]*$/i;\n\n  // The token here is defined in js-tokens@4. However we don't bother\n  // typing it since the whole block will be removed in Babel 8\n  const getTokenType = function (token: any, offset: number, text: string) {\n    if (token.type === \"name\") {\n      if (\n        isKeyword(token.value) ||\n        isStrictReservedWord(token.value, true) ||\n        sometimesKeywords.has(token.value)\n      ) {\n        return \"keyword\";\n      }\n\n      if (\n        JSX_TAG.test(token.value) &&\n        (text[offset - 1] === \"<\" || text.slice(offset - 2, offset) == \"</\")\n      ) {\n        return \"jsxIdentifier\";\n      }\n\n      if (token.value[0] !== token.value[0].toLowerCase()) {\n        return \"capitalized\";\n      }\n    }\n\n    if (token.type === \"punctuator\" && BRACKET.test(token.value)) {\n      return \"bracket\";\n    }\n\n    if (\n      token.type === \"invalid\" &&\n      (token.value === \"@\" || token.value === \"#\")\n    ) {\n      return \"punctuator\";\n    }\n\n    return token.type;\n  };\n\n  tokenize = function* (text: string) {\n    let match;\n    while ((match = (jsTokens as any).default.exec(text))) {\n      const token = (jsTokens as any).matchToToken(match);\n\n      yield {\n        type: getTokenType(token, match.index, text),\n        value: token.value,\n      };\n    }\n  };\n}\n\n/**\n * Highlight `text` using the token definitions in `defs`.\n */\nfunction highlightTokens(defs: Record<string, Chalk>, text: string) {\n  let highlighted = \"\";\n\n  for (const { type, value } of tokenize(text)) {\n    const colorize = defs[type];\n    if (colorize) {\n      highlighted += value\n        .split(NEWLINE)\n        .map(str => colorize(str))\n        .join(\"\\n\");\n    } else {\n      highlighted += value;\n    }\n  }\n\n  return highlighted;\n}\n\n/**\n * Highlight `text` using the token definitions in `defs`.\n */\n\ntype Options = {\n  forceColor?: boolean;\n};\n\n/**\n * Whether the code should be highlighted given the passed options.\n */\nexport function shouldHighlight(options: Options): boolean {\n  return chalk.level > 0 || options.forceColor;\n}\n\nlet chalkWithForcedColor: Chalk = undefined;\nfunction getChalk(forceColor: boolean) {\n  if (forceColor) {\n    chalkWithForcedColor ??= process.env.BABEL_8_BREAKING\n      ? new ChalkClass({ level: 1 })\n      : // @ts-expect-error .Instance was .constructor in chalk 2\n        new chalk.constructor({ enabled: true, level: 1 });\n    return chalkWithForcedColor;\n  }\n  return chalk;\n}\nif (!process.env.BABEL_8_BREAKING && !USE_ESM) {\n  // eslint-disable-next-line no-restricted-globals\n  exports.getChalk = (options: Options) => getChalk(options.forceColor);\n}\n\n/**\n * Highlight `code`.\n */\nexport default function highlight(code: string, options: Options = {}): string {\n  if (code !== \"\" && shouldHighlight(options)) {\n    const defs = getDefs(getChalk(options.forceColor));\n    return highlightTokens(defs, code);\n  } else {\n    return code;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}